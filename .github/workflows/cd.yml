name: CD
run-name: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.display_title) || (github.event_name == 'workflow_dispatch' && format('Deploy {0}', inputs.tag || github.ref_name || github.sha)) || format('Deploy {0}', github.ref_name || github.sha) }}

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [ main ]
  workflow_dispatch:
    inputs:
      tag:
        description: Image tag to deploy (semver vX.Y.Z or short SHA). Leave empty to use computed tag
        required: false
      environment:
        description: Target environment
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging

permissions:
  contents: read
  packages: read

env:
  DEFAULT_VPS_PATH: /opt/metro
  REGISTRY: ghcr.io/${{ github.repository_owner }}
  GHCR_HOST: ghcr.io

jobs:
  # Job 1: Setup and validation
  setup-deploy:
    name: Setup deployment
    runs-on: ubuntu-latest
    if: >
      ${{
        github.event_name == 'workflow_dispatch' ||
        (
          github.event_name == 'workflow_run' &&
          github.event.workflow_run.conclusion == 'success' &&
          github.event.workflow_run.event == 'push'
        )
      }}
    outputs:
      deploy_tag: ${{ steps.tag.outputs.value }}
      registry: ${{ steps.vars.outputs.registry }}
      services: ${{ steps.services.outputs.services }}
    steps:
      - name: Normalize REGISTRY
        id: vars
        run: echo "registry=ghcr.io/${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT

      - name: Resolve deploy tag
        id: tag
        run: |
          if [[ -n "${{ inputs.tag || '' }}" ]]; then
            echo "value=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            SHA="${{ github.event.workflow_run.head_sha }}"
            echo "value=${SHA:0:7}" >> $GITHUB_OUTPUT
          else
            echo "value=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          fi
          echo "Resolved tag: $(sed -n 's/^value=//p' $GITHUB_OUTPUT)"

      - name: Generate services list
        id: services
        run: |
          services='[
            "api-gateway", "auth-service", "payment-service", "public-service",
            "ticket-service", "transport-service", "user-service", "report-service",
            "management-service", "control-service", "notification-service",
            "webhook", "scheduler-service", "healthcheck"
          ]'
          echo "services=$(echo "$services" | jq -c .)" >> $GITHUB_OUTPUT

  # Job 2: Verify images parallel
  verify-images:
    name: Verify images
    needs: setup-deploy
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      max-parallel: 8
      matrix:
        service: ${{ fromJson(needs.setup-deploy.outputs.services) }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image exists
        run: |
          REF="${{ needs.setup-deploy.outputs.registry }}/metro-${{ matrix.service }}:${{ needs.setup-deploy.outputs.deploy_tag }}"
          echo "Checking $REF"
          if ! docker manifest inspect "$REF" >/dev/null 2>&1; then
            echo "Missing image: $REF" >&2
            exit 1
          fi
          echo "✓ $REF exists"

  # Job 3: Pre-pull images parallel
  pre-pull-images:
    name: Pre-pull images
    needs: [setup-deploy, verify-images]
    runs-on: [self-hosted]
    if: inputs.environment != 'staging'
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix:
        service: ${{ fromJson(needs.setup-deploy.outputs.services) }}
    steps:
      - name: Login to GHCR
        env:
          REGISTRY_USER: ${{ secrets.GHCR_USERNAME || github.actor }}
          REGISTRY_TOKEN: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "$REGISTRY_TOKEN" | docker login ghcr.io -u "$REGISTRY_USER" --password-stdin

      - name: Pull image
        env:
          REGISTRY: ${{ needs.setup-deploy.outputs.registry }}
          IMAGE_TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
        run: |
          IMAGE="$REGISTRY/metro-${{ matrix.service }}:$IMAGE_TAG"
          echo "Pulling $IMAGE"
          docker pull "$IMAGE" || {
            echo "Failed to pull $IMAGE" >&2
            exit 1
          }
          echo "✓ Pulled $IMAGE"

  # Job 4: Deploy main
  deploy-vps:
    name: Deploy to VPS
    needs: [setup-deploy, verify-images, pre-pull-images]
    runs-on: [self-hosted]
    timeout-minutes: 30
    if: always() && needs.setup-deploy.result == 'success' && needs.verify-images.result == 'success' && (needs.pre-pull-images.result == 'success' || needs.pre-pull-images.result == 'skipped')
    concurrency:
      group: deploy-selfhosted-${{ github.ref_name }}
      cancel-in-progress: false
    steps:
      - name: Clean workspace
        run: |
          chmod -R u+w "$GITHUB_WORKSPACE" 2>/dev/null || true
          rm -rf "$GITHUB_WORKSPACE/nginx/certs/" "$GITHUB_WORKSPACE/.git/" 2>/dev/null || true
          sudo chown -R "$(whoami):$(whoami)" "$GITHUB_WORKSPACE" 2>/dev/null || true

      - name: Checkout
        uses: actions/checkout@v4
        with:
          clean: false

      - name: Login to GHCR
        env:
          REGISTRY_USER: ${{ secrets.GHCR_USERNAME || github.actor }}
          REGISTRY_TOKEN: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "$REGISTRY_TOKEN" | docker login ghcr.io -u "$REGISTRY_USER" --password-stdin

      - name: Determine deploy directory
        id: deploy_dir
        run: |
          DEPLOY_DIR="$GITHUB_WORKSPACE"
          if [ ! -f "$DEPLOY_DIR/docker-compose.prod.yml" ] \
             && [ ! -f "$DEPLOY_DIR/compose.prod.yml" ] \
             && [ ! -f "$DEPLOY_DIR/docker-compose.yml" ] \
             && [ ! -f "$DEPLOY_DIR/compose.yml" ]; then
            DEPLOY_DIR="${{ secrets.VPS_PATH || env.DEFAULT_VPS_PATH }}"
          fi
          echo "dir=$DEPLOY_DIR" >> $GITHUB_OUTPUT
          echo "Using deploy directory: $DEPLOY_DIR"

      - name: Detect compose file
        id: compose
        working-directory: ${{ steps.deploy_dir.outputs.dir }}
        run: |
          if   [ -f docker-compose.prod.yml ]; then echo "file=docker-compose.prod.yml" >> $GITHUB_OUTPUT
          elif [ -f compose.prod.yml ];        then echo "file=compose.prod.yml" >> $GITHUB_OUTPUT
          elif [ -f docker-compose.yml ];      then echo "file=docker-compose.yml" >> $GITHUB_OUTPUT
          elif [ -f compose.yml ];             then echo "file=compose.yml" >> $GITHUB_OUTPUT
          else echo "No compose file found" >&2; exit 1; fi
          echo "Using compose file: $(cat $GITHUB_OUTPUT | grep '^file=' | cut -d= -f2)"

      - name: Pull images (parallel)
        working-directory: ${{ steps.deploy_dir.outputs.dir }}
        env:
          TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          IMAGE_TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          REGISTRY: ${{ needs.setup-deploy.outputs.registry }}
        run: |
          echo "Pulling images for tag: $TAG"
          timeout 300 docker compose -f ${{ steps.compose.outputs.file }} pull --parallel --quiet || {
            echo "Parallel pull failed, retrying sequentially..."
            docker compose -f ${{ steps.compose.outputs.file }} pull
          }

      - name: Deploy services
        working-directory: ${{ steps.deploy_dir.outputs.dir }}
        env:
          TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          IMAGE_TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          REGISTRY: ${{ needs.setup-deploy.outputs.registry }}
          COMPOSE_PROFILES: nginx,admin-tools
        run: |
          echo "Deploying with tag: $TAG"
          
          docker compose -f ${{ steps.compose.outputs.file }} \
            --profile nginx --profile admin-tools \
            up -d --remove-orphans --no-deps --force-recreate

      - name: Health check
        working-directory: ${{ steps.deploy_dir.outputs.dir }}
        env:
          TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          IMAGE_TAG: ${{ needs.setup-deploy.outputs.deploy_tag }}
          REGISTRY: ${{ needs.setup-deploy.outputs.registry }}
        run: |
          echo "Checking service health..."
          docker compose -f ${{ steps.compose.outputs.file }} ps
          
          for i in {1..30}; do
            if docker compose -f ${{ steps.compose.outputs.file }} ps --services --filter "status=running" | wc -l | grep -q "^[1-9]"; then
              echo "✓ Services are running"
              break
            fi
            echo "Waiting for services... ($i/30)"
            sleep 2
          done

      - name: Cleanup
        if: always()
        run: |
          docker image prune -f --filter "dangling=true" || true
          docker system df

  # Job 5: Post-deploy validation (parallel)
  post-deploy-check:
    name: Post-deploy validation
    needs: [setup-deploy, deploy-vps]
    runs-on: [self-hosted]
    if: always() && needs.deploy-vps.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        check: ['health', 'connectivity', 'logs']
    steps:
      - name: Health check
        if: matrix.check == 'health'
        run: |
          echo "Running health checks..."
          curl -f http://localhost/health || echo "Health check endpoint not available"

      - name: Connectivity check  
        if: matrix.check == 'connectivity'
        run: |
          echo "Testing service connectivity..."
          docker network ls

      - name: Check logs
        if: matrix.check == 'logs'
        run: |
          echo "Checking recent logs for errors..."
          docker compose logs --tail=50 | grep -i error | tail -10 || true